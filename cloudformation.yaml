# =====================================================================
# Driver Drowsiness Alert System CloudFormation Template - WEBSOCKET VERSION
#
# Key Features:
# - Real-time WebSocket communication for ambulance dashboard
# - Connection management for multiple dashboard instances
# - Instant alert delivery without polling
# - Professional and organized structure
# - Free Tier optimized
#
# Deployment Instructions:
# 1. Update parameters as needed (e.g., Environment)
# 2. Deploy with:
#    aws cloudformation deploy --template-file cloudformation.yaml --stack-name drowsiness-alert-system --capabilities CAPABILITY_IAM
# 3. Check Outputs for WebSocket endpoint and other resource ARNs
# =====================================================================

AWSTemplateFormatVersion: '2010-09-09'
Description: |
  Car Drowsiness Alert System Infrastructure with WebSocket Support (Free Tier Optimized)
  
  Tables:
  1. DriversTable: Stores driver profiles with medical info
  2. AlertsTable: Stores drowsiness alerts with driver info
  3. WebSocketConnectionsTable: Manages active WebSocket connections for real-time alerts
  
  WebSocket Features:
  - Real-time alert delivery to ambulance dashboard
  - Connection management and cleanup
  - Instant notification without polling
  - Support for multiple dashboard instances

Parameters:
  Environment:
    Type: String
    Default: dev
    AllowedValues: [dev, staging, prod]
    Description: Deployment environment

Resources:
  # =====================================================================
  # IoT Core Policy (Free Tier: 250,000 messages/month)
  # =====================================================================
  DrowsinessAlertPolicy:
    Type: AWS::IoT::Policy
    Properties:
      PolicyName: !Sub "drowsiness-alert-policy-${Environment}"
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - 'iot:Connect'
              - 'iot:Publish'
              - 'iot:Subscribe'
              - 'iot:Receive'
            Resource: '*'

  # =====================================================================
  # DynamoDB Tables (Free Tier: 25 WCU and 25 RCU)
  # =====================================================================
  DriversTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "drivers-${Environment}"
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      SSESpecification:
        SSEEnabled: true
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: FreeTier
          Value: "true"
        - Key: Purpose
          Value: "Driver Profiles"
        - Key: DataClassification
          Value: "Sensitive"

  AlertsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "drowsiness_alerts-${Environment}"
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: alert_id
          AttributeType: S
        - AttributeName: driver_id
          AttributeType: S
        - AttributeName: timestamp
          AttributeType: S
      KeySchema:
        - AttributeName: alert_id
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: driver_id-timestamp-index
          KeySchema:
            - AttributeName: driver_id
              KeyType: HASH
            - AttributeName: timestamp
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      SSESpecification:
        SSEEnabled: true
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: FreeTier
          Value: "true"
        - Key: Purpose
          Value: "Drowsiness Alerts"
        - Key: DataClassification
          Value: "Sensitive"

  # WebSocket Connections Table for Real-time Dashboard Management
  WebSocketConnectionsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "websocket-connections-${Environment}"
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: connection_id
          AttributeType: S
        - AttributeName: user_id
          AttributeType: S
      KeySchema:
        - AttributeName: connection_id
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: user_id-index
          KeySchema:
            - AttributeName: user_id
              KeyType: HASH
          Projection:
            ProjectionType: ALL
      TimeToLiveSpecification:
        AttributeName: ttl
        Enabled: true
      SSESpecification:
        SSEEnabled: true
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: FreeTier
          Value: "true"
        - Key: Purpose
          Value: "WebSocket Connections"
        - Key: DataClassification
          Value: "Internal"

  # =====================================================================
  # IAM Role for Lambda Functions
  # =====================================================================
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
      Policies:
        - PolicyName: DrowsinessAlertLambdaPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'dynamodb:GetItem'
                  - 'dynamodb:PutItem'
                  - 'dynamodb:UpdateItem'
                  - 'dynamodb:Query'
                  - 'dynamodb:Scan'
                  - 'dynamodb:DeleteItem'
                  - 'dynamodb:BatchGetItem'
                  - 'dynamodb:BatchWriteItem'
                  - 'dynamodb:DescribeTable'
                Resource: 
                  - !GetAtt DriversTable.Arn
                  - !GetAtt AlertsTable.Arn
                  - !GetAtt WebSocketConnectionsTable.Arn
                  - !Sub "${AlertsTable.Arn}/index/*"
                  - !Sub "${WebSocketConnectionsTable.Arn}/index/*"
              - Effect: Allow
                Action:
                  - 'iot:Publish'
                  - 'iot:Connect'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'execute-api:ManageConnections'
                Resource: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*"
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: 'arn:aws:logs:*:*:*'

  # =====================================================================
  # Lambda Functions
  # =====================================================================
  UpdateDriverProfileFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "update_driver_profile-${Environment}"
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.9
      Timeout: 30
      MemorySize: 128
      Environment:
        Variables:
          DRIVERS_TABLE: !Ref DriversTable
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          import json
          import boto3
          import uuid
          from datetime import datetime, timedelta
          import os
          import logging
          import re

          # Configure logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          logger.info("Lambda module imported successfully")

          # Initialize AWS services
          dynamodb = boto3.resource('dynamodb')

          # Get table names from environment variables
          DRIVERS_TABLE = os.environ.get('DRIVERS_TABLE', 'drivers')

          def validate_name(name):
              """Validate driver name"""
              if not name or not isinstance(name, str):
                  return None, "Name must be a non-empty string"
              
              # Remove special characters and extra spaces
              name = re.sub(r'[^a-zA-Z\s\-\.]', '', name)
              name = ' '.join(name.split())
              
              if len(name) < 2:
                  return None, "Name must be at least 2 characters long"
              if len(name) > 100:
                  return None, "Name must not exceed 100 characters"
              
              return name, None

          def validate_gender(gender):
              """Validate gender"""
              if not gender or not isinstance(gender, str):
                  return None, "Gender must be a non-empty string"
              
              gender = gender.strip().lower()
              valid_genders = ['male', 'female', 'other', 'm', 'f', 'o']
              
              # Map short forms to full forms
              gender_map = {'m': 'male', 'f': 'female', 'o': 'other'}
              gender = gender_map.get(gender, gender)
              
              if gender not in ['male', 'female', 'other']:
                  return None, "Gender must be one of: male, female, other"
              
              return gender, None

          def validate_date_of_birth(dob):
              """Validate date of birth"""
              if not dob or not isinstance(dob, str):
                  return None, "Date of birth must be a non-empty string in YYYY-MM-DD format"
              
              try:
                  dob_date = datetime.strptime(dob, '%Y-%m-%d')
                  today = datetime.now()
                  
                  # Check if date is in the future
                  if dob_date > today:
                      return None, "Date of birth cannot be in the future"
                  
                  # Calculate age
                  age = (today - dob_date).days / 365.25
                  
                  if age < 16:
                      return None, "Driver must be at least 16 years old"
                  if age > 100:
                      return None, "Invalid date of birth (age over 100)"
                  
                  return dob, None
              except ValueError:
                  return None, "Invalid date format. Use YYYY-MM-DD"

          def validate_weight(weight):
              """Validate weight in kg"""
              if weight is None:
                  return None, "Weight is required"
              
              try:
                  weight = float(weight)
                  if weight < 20:
                      return None, "Weight must be at least 20 kg"
                  if weight > 300:
                      return None, "Weight must not exceed 300 kg"
                  return round(weight, 1), None  # Round to 1 decimal place
              except (ValueError, TypeError):
                  return None, "Weight must be a valid number"

          def validate_height(height):
              """Validate height in cm"""
              if height is None:
                  return None, "Height is required"
              
              try:
                  height = float(height)
                  if height < 100:
                      return None, "Height must be at least 100 cm"
                  if height > 250:
                      return None, "Height must not exceed 250 cm"
                  return round(height, 1), None  # Round to 1 decimal place
              except (ValueError, TypeError):
                  return None, "Height must be a valid number"

          def validate_emergency_contact(contact):
              """Validate emergency contact phone number"""
              if not contact or not isinstance(contact, str):
                  return None, "Emergency contact is required"
              
              # Remove all non-digit characters
              digits = re.sub(r'\D', '', contact)
              
              # Validate length
              if len(digits) < 10:
                  return None, "Emergency contact must have at least 10 digits"
              if len(digits) > 15:
                  return None, "Emergency contact must not exceed 15 digits"
              
              # Format the number
              if len(digits) == 10:
                  return f"+1{digits}", None  # Add country code for 10-digit numbers
              return f"+{digits}", None

          def validate_blood_type(blood_type):
              """Validate blood type"""
              if not blood_type or not isinstance(blood_type, str):
                  return None, "Blood type is required"
              
              blood_type = blood_type.strip().upper()
              valid_types = ['A+', 'A-', 'B+', 'B-', 'AB+', 'AB-', 'O+', 'O-']
              
              if blood_type not in valid_types:
                  return None, f"Blood type must be one of: {', '.join(valid_types)}"
              
              return blood_type, None

          def validate_chronic_diseases(diseases):
              """Validate chronic diseases list"""
              if not diseases:
                  return [], None
              
              if not isinstance(diseases, list):
                  return None, "Chronic diseases must be a list"
              
              valid_diseases = []
              for disease in diseases:
                  if not isinstance(disease, str):
                      continue
                  
                  # Sanitize disease name
                  disease = re.sub(r'[^a-zA-Z\s\-]', '', disease)
                  disease = ' '.join(disease.split())
                  
                  if disease and len(disease) <= 100:
                      valid_diseases.append(disease)
              
              if len(valid_diseases) > 20:
                  return None, "Maximum 20 chronic diseases allowed"
              
              return valid_diseases, None

          def validate_allergies(allergies):
              """Validate allergies list"""
              if not allergies:
                  return [], None
              
              if not isinstance(allergies, list):
                  return None, "Allergies must be a list"
              
              valid_allergies = []
              for allergy in allergies:
                  if not isinstance(allergy, str):
                      continue
                  
                  # Sanitize allergy name
                  allergy = re.sub(r'[^a-zA-Z\s\-]', '', allergy)
                  allergy = ' '.join(allergy.split())
                  
                  if allergy and len(allergy) <= 50:
                      valid_allergies.append(allergy)
              
              if len(valid_allergies) > 30:
                  return None, "Maximum 30 allergies allowed"
              
              return valid_allergies, None

          def lambda_handler(event, context):
              """
              Lambda function to handle driver profile updates.
              """
              logger.info(f"Received driver profile update: {json.dumps(event)}")
              
              drivers_table = dynamodb.Table(DRIVERS_TABLE)
              
              try:
                  driver_id = event.get('id')
                  if not driver_id:
                      raise ValueError("Update missing id")
                  
                  ttl = int((datetime.utcnow() + timedelta(days=365)).timestamp())
                  
                  # Validate all fields
                  validation_results = {
                      'id': (driver_id, None),
                      'name': validate_name(event.get('name')),
                      'gender': validate_gender(event.get('gender')),
                      'date_of_birth': validate_date_of_birth(event.get('date_of_birth')),
                      'weight': validate_weight(event.get('weight')),
                      'height': validate_height(event.get('height')),
                      'emergency_contact': validate_emergency_contact(event.get('emergency_contact')),
                      'blood_type': validate_blood_type(event.get('blood_type')),
                      'chronic_diseases': validate_chronic_diseases(event.get('chronic_diseases', [])),
                      'allergies': validate_allergies(event.get('allergies', [])),
                      'last_updated': (datetime.utcnow().isoformat(), None),
                      'ttl': (ttl, None)
                  }
                  
                  # Check for validation errors
                  errors = {k: v[1] for k, v in validation_results.items() if v[1] is not None}
                  if errors:
                      return {
                          'statusCode': 400,
                          'body': json.dumps({
                              'message': 'Validation errors',
                              'errors': errors
                          })
                      }
                  
                  # Create update data with validated values
                  update_data = {k: v[0] for k, v in validation_results.items() if v[0] is not None}
                  
                  drivers_table.put_item(Item=update_data)
                  
                  logger.info(f"Successfully updated driver profile for {driver_id}")
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Driver profile updated successfully',
                          'id': driver_id
                      })
                  }
                  
              except Exception as e:
                  logger.error(f"Error updating driver profile: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'message': f'Error updating profile: {str(e)}'
                      })
                  }

  ProcessDrowsinessAlertFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "process_drowsiness_alert-${Environment}"
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.9
      Timeout: 30
      MemorySize: 128
      Environment:
        Variables:
          DRIVERS_TABLE: !Ref DriversTable
          ALERTS_TABLE: !Ref AlertsTable
          WEBSOCKET_CONNECTIONS_TABLE: !Ref WebSocketConnectionsTable
          ENVIRONMENT: !Ref Environment
          WEBSOCKET_API_ENDPOINT: !Sub "https://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/${Environment}"
      Code:
        ZipFile: |
          import json
          import boto3
          import uuid
          import time
          from datetime import datetime, timedelta
          import os
          import logging
          import traceback
          from decimal import Decimal
          import decimal

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          logger.info("ProcessDrowsinessAlert Lambda started")

          dynamodb = boto3.resource('dynamodb')

          DRIVERS_TABLE = os.environ.get('DRIVERS_TABLE', 'drivers')
          ALERTS_TABLE = os.environ.get('ALERTS_TABLE', 'drowsiness_alerts')
          WEBSOCKET_CONNECTIONS_TABLE = os.environ.get('WEBSOCKET_CONNECTIONS_TABLE', 'websocket-connections')
          WEBSOCKET_API_ENDPOINT = os.environ.get('WEBSOCKET_API_ENDPOINT')

          def decimal_default(obj):
              if isinstance(obj, decimal.Decimal):
                  return float(obj)
              raise TypeError

          def send_to_websocket_connections(alert_data):
              """Send alert to all connected WebSocket clients"""
              try:
                  # Get all active connections
                  connections_table = dynamodb.Table(WEBSOCKET_CONNECTIONS_TABLE)
                  response = connections_table.scan()
                  
                  if not response.get('Items'):
                      logger.info("No active WebSocket connections found")
                      return
                  
                  # Initialize API Gateway Management API client
                  apigw_client = boto3.client(
                      'apigatewaymanagementapi',
                      endpoint_url=WEBSOCKET_API_ENDPOINT
                  )
                  
                  # Send alert to each connected client
                  for connection in response['Items']:
                      connection_id = connection['connection_id']
                      try:
                          apigw_client.post_to_connection(
                              ConnectionId=connection_id,
                              Data=json.dumps(alert_data, default=decimal_default)
                          )
                          logger.info(f"Sent alert to connection: {connection_id}")
                      except Exception as e:
                          logger.warning(f"Failed to send to connection {connection_id}: {str(e)}")
                          # Remove stale connection
                          try:
                              connections_table.delete_item(Key={'connection_id': connection_id})
                              logger.info(f"Removed stale connection: {connection_id}")
                          except:
                              pass
                  
                  logger.info(f"Alert sent to {len(response['Items'])} WebSocket connections")
                  
              except Exception as e:
                  logger.error(f"Error sending to WebSocket connections: {str(e)}")

          def lambda_handler(event, context):
              logger.info(f"Received drowsiness alert event: {json.dumps(event, default=str)}")
              
              drivers_table = dynamodb.Table(DRIVERS_TABLE)
              alerts_table = dynamodb.Table(ALERTS_TABLE)
              
              try:
                  # Extract data from event
                  alert_id = event.get('alert_id')
                  driver_id = event.get('driver_id')
                  timestamp = event.get('timestamp', datetime.utcnow().isoformat())
                  location = event.get('location', {})
                  message = event.get('message', 'Driver fell asleep')
                  
                  logger.info(f"Processing alert - ID: {alert_id}, Driver: {driver_id}")
                  
                  if not driver_id:
                      raise ValueError("Alert missing driver_id")
                  
                  if not alert_id:
                      alert_id = str(uuid.uuid4())
                      logger.info(f"Generated new alert_id: {alert_id}")
                  
                  ttl = int((datetime.utcnow() + timedelta(days=30)).timestamp())
                  
                  # Build location object with proper handling
                  location_obj = {}
                  if isinstance(location, dict):
                      if 'latitude' in location and location['latitude'] is not None:
                          location_obj['latitude'] = Decimal(str(location['latitude']))
                      if 'longitude' in location and location['longitude'] is not None:
                          location_obj['longitude'] = Decimal(str(location['longitude']))
                      if 'description' in location and location['description']:
                          location_obj['description'] = str(location['description'])
                  
                  # Build alert record
                  alert_record = {
                      'alert_id': alert_id,
                      'driver_id': driver_id,
                      'timestamp': timestamp,
                      'message': message,
                      'processed': True,
                      'ttl': ttl
                  }
                  
                  # Add location if it exists
                  if location_obj:
                      alert_record['location'] = location_obj
                  
                  logger.info(f"Writing alert to DynamoDB: {json.dumps(alert_record, default=str)}")
                  
                  # Write to DynamoDB with retry logic
                  max_retries = 3
                  for attempt in range(max_retries):
                      try:
                          alerts_table.put_item(Item=alert_record)
                          logger.info(f"Successfully wrote alert to DynamoDB on attempt {attempt + 1}")
                          break
                      except Exception as write_error:
                          logger.error(f"DynamoDB write attempt {attempt + 1} failed: {str(write_error)}")
                          if attempt == max_retries - 1:
                              raise write_error
                          time.sleep(0.5 * (attempt + 1))  # Exponential backoff
                  
                  # Get driver info
                  try:
                      driver_response = drivers_table.get_item(Key={'id': driver_id})
                      if 'Item' in driver_response:
                          driver_info = driver_response['Item']
                          logger.info(f"Found driver info for {driver_id}")
                      else:
                          logger.warning(f"Driver with ID {driver_id} not found in database")
                          driver_info = {
                              'id': driver_id,
                              'name': 'Unknown Driver',
                              'emergency_contact': 'Not available'
                          }
                  except Exception as driver_error:
                      logger.error(f"Error fetching driver info: {str(driver_error)}")
                      driver_info = {
                          'id': driver_id,
                          'name': 'Unknown Driver',
                          'emergency_contact': 'Not available'
                      }
                  
                  # Prepare combined alert for ambulance dashboard
                  complete_alert = {
                      'type': 'drowsiness_alert',
                      'alert': alert_record,
                      'driver_info': driver_info,
                      'processed_at': datetime.utcnow().isoformat()
                  }
                  
                  # Send to ambulance dashboard via WebSocket (REAL-TIME)
                  send_to_websocket_connections(complete_alert)
                  
                  # Send acknowledgment back to vehicle via IoT
                  try:
                      acknowledgment = {
                          'alert_id': alert_id,
                          'status': 'processed',
                          'timestamp': datetime.utcnow().isoformat(),
                          'message': 'Alert received and processed successfully'
                      }
                      
                      iot_client = boto3.client('iot-data')
                      iot_client.publish(
                          topic='vehicle/alerts/ack',
                          qos=1,
                          payload=json.dumps(acknowledgment)
                      )
                      logger.info(f"Sent acknowledgment to vehicle for alert: {alert_id}")
                  except Exception as iot_error:
                      logger.error(f"Failed to send IoT acknowledgment: {str(iot_error)}")
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Alert processed successfully',
                          'alert_id': alert_id,
                          'driver_id': driver_id
                      })
                  }
                  
              except Exception as e:
                  logger.error(f"Error processing drowsiness alert: {str(e)}")
                  logger.error(f"Traceback: {traceback.format_exc()}")
                  
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'message': f'Error processing alert: {str(e)}',
                          'alert_id': event.get('alert_id', 'unknown')
                      })
                  }

  # =====================================================================
  # WebSocket API Gateway and Lambda Functions
  # =====================================================================
  WebSocketApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: !Sub "drowsiness-alert-websocket-${Environment}"
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: "$request.body.action"

  WebSocketConnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: $connect
      AuthorizationType: NONE
      OperationName: ConnectRoute
      Target: !Sub "integrations/${WebSocketConnectIntegration}"

  WebSocketDisconnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: $disconnect
      AuthorizationType: NONE
      OperationName: DisconnectRoute
      Target: !Sub "integrations/${WebSocketDisconnectIntegration}"

  WebSocketDefaultRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: $default
      AuthorizationType: NONE
      OperationName: DefaultRoute
      Target: !Sub "integrations/${WebSocketDefaultIntegration}"

  WebSocketConnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${WebSocketConnectFunction.Arn}/invocations"

  WebSocketDisconnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${WebSocketDisconnectFunction.Arn}/invocations"

  WebSocketDefaultIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${WebSocketDefaultFunction.Arn}/invocations"

  WebSocketStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref WebSocketApi
      StageName: !Ref Environment
      AutoDeploy: true

  # WebSocket Lambda Functions
  WebSocketConnectFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "websocket-connect-${Environment}"
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.9
      Timeout: 30
      MemorySize: 128
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Ref WebSocketConnectionsTable
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          import json
          import boto3
          from datetime import datetime, timedelta
          import os
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          dynamodb = boto3.resource('dynamodb')
          WEBSOCKET_CONNECTIONS_TABLE = os.environ.get('WEBSOCKET_CONNECTIONS_TABLE')

          def lambda_handler(event, context):
              logger.info(f"WebSocket connect event: {json.dumps(event)}")
              
              try:
                  connection_id = event['requestContext']['connectionId']
                  user_id = event.get('queryStringParameters', {}).get('userId', 'anonymous')
                  
                  # Store connection in DynamoDB
                  connections_table = dynamodb.Table(WEBSOCKET_CONNECTIONS_TABLE)
                  ttl = int((datetime.utcnow() + timedelta(hours=24)).timestamp())
                  
                  connections_table.put_item(Item={
                      'connection_id': connection_id,
                      'user_id': user_id,
                      'connected_at': datetime.utcnow().isoformat(),
                      'ttl': ttl
                  })
                  
                  logger.info(f"Stored WebSocket connection: {connection_id} for user: {user_id}")
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Connected successfully',
                          'connection_id': connection_id
                      })
                  }
                  
              except Exception as e:
                  logger.error(f"Error in WebSocket connect: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'message': f'Connection failed: {str(e)}'
                      })
                  }

  WebSocketDisconnectFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "websocket-disconnect-${Environment}"
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.9
      Timeout: 30
      MemorySize: 128
      Environment:
        Variables:
          WEBSOCKET_CONNECTIONS_TABLE: !Ref WebSocketConnectionsTable
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          dynamodb = boto3.resource('dynamodb')
          WEBSOCKET_CONNECTIONS_TABLE = os.environ.get('WEBSOCKET_CONNECTIONS_TABLE')

          def lambda_handler(event, context):
              logger.info(f"WebSocket disconnect event: {json.dumps(event)}")
              
              try:
                  connection_id = event['requestContext']['connectionId']
                  
                  # Remove connection from DynamoDB
                  connections_table = dynamodb.Table(WEBSOCKET_CONNECTIONS_TABLE)
                  connections_table.delete_item(Key={'connection_id': connection_id})
                  
                  logger.info(f"Removed WebSocket connection: {connection_id}")
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Disconnected successfully'
                      })
                  }
                  
              except Exception as e:
                  logger.error(f"Error in WebSocket disconnect: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'message': f'Disconnect failed: {str(e)}'
                      })
                  }

  WebSocketDefaultFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "websocket-default-${Environment}"
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.9
      Timeout: 30
      MemorySize: 128
      Environment:
        Variables:
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          import json
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.info(f"WebSocket default event: {json.dumps(event)}")
              
              try:
                  # Handle any other WebSocket messages
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Message received',
                          'action': 'default'
                      })
                  }
                  
              except Exception as e:
                  logger.error(f"Error in WebSocket default: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({
                          'message': f'Error: {str(e)}'
                      })
                  }

  # =====================================================================
  # REST API Gateway (for backward compatibility)
  # =====================================================================
  DrowsinessAlertApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub "drowsiness-alert-api-${Environment}"
      Description: API for Driver Drowsiness Alert System

  ApiGatewayDriverResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref DrowsinessAlertApi
      ParentId: !GetAtt DrowsinessAlertApi.RootResourceId
      PathPart: driver-profile

  ApiGatewayDriverMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref DrowsinessAlertApi
      ResourceId: !Ref ApiGatewayDriverResource
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${HttpUpdateProfileFunction.Arn}/invocations"

  ApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn: 
      - ApiGatewayDriverMethod
    Properties:
      RestApiId: !Ref DrowsinessAlertApi

  ApiGatewayStage:
    Type: AWS::ApiGateway::Stage
    Properties:
      RestApiId: !Ref DrowsinessAlertApi
      DeploymentId: !Ref ApiGatewayDeployment
      StageName: !Ref Environment

  HttpUpdateProfileFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "http_update_profile-${Environment}"
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Runtime: python3.9
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          DRIVERS_TABLE: !Ref DriversTable
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          import json
          import boto3
          from datetime import datetime, timedelta
          import os
          import logging
          import traceback
          from decimal import Decimal

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          dynamodb = boto3.resource('dynamodb')
          iot_client = boto3.client('iot-data')

          DRIVERS_TABLE = os.environ.get('DRIVERS_TABLE', 'drivers')

          def lambda_handler(event, context):
              logger.info(f"Received HTTP profile update request: {json.dumps(event, default=str)}")
              
              try:
                  # Parse request body
                  if 'body' not in event:
                      return {
                          'statusCode': 400,
                          'headers': {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': '*'
                          },
                          'body': json.dumps({'message': 'Request body is missing'})
                      }
                  
                  body = json.loads(event['body'])
                  
                  # Validate required fields
                  if not body.get('id'):
                      return {
                          'statusCode': 400,
                          'headers': {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': '*'
                          },
                          'body': json.dumps({'message': 'Driver ID is required'})
                      }
                  
                  # Prepare data for DynamoDB
                  driver_data = {
                      'id': body['id'],
                      'name': body.get('name', 'Unknown Driver'),
                      'gender': body.get('gender', 'unknown'),
                      'date_of_birth': body.get('date_of_birth', ''),
                      'weight': Decimal(str(body.get('weight', 0))),
                      'height': Decimal(str(body.get('height', 0))),
                      'emergency_contact': body.get('emergency_contact', ''),
                      'blood_type': body.get('blood_type', ''),
                      'chronic_diseases': body.get('chronic_diseases', []),
                      'allergies': body.get('allergies', []),
                      'last_updated': datetime.utcnow().isoformat(),
                      'ttl': int((datetime.utcnow() + timedelta(days=365)).timestamp())
                  }
                  
                  # Store in DynamoDB
                  drivers_table = dynamodb.Table(DRIVERS_TABLE)
                  drivers_table.put_item(Item=driver_data)
                  
                  return {
                      'statusCode': 200,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': json.dumps({
                          'message': 'Driver profile updated successfully',
                          'id': body['id']
                      })
                  }
                  
              except Exception as e:
                  logger.error(f"Error updating profile: {str(e)}")
                  logger.error(f"Traceback: {traceback.format_exc()}")
                  return {
                      'statusCode': 500,
                      'headers': {
                          'Content-Type': 'application/json',
                          'Access-Control-Allow-Origin': '*'
                      },
                      'body': json.dumps({
                          'message': f'Error updating profile: {str(e)}'
                      })
                  }

  # =====================================================================
  # Lambda Permissions
  # =====================================================================
  DrowsinessAlertRuleLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref ProcessDrowsinessAlertFunction
      Principal: iot.amazonaws.com
      SourceArn: !GetAtt DrowsinessAlertRule.Arn

  DriverProfileRuleLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref UpdateDriverProfileFunction
      Principal: iot.amazonaws.com
      SourceArn: !GetAtt DriverProfileRule.Arn

  WebSocketConnectLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref WebSocketConnectFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/*"

  WebSocketDisconnectLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref WebSocketDisconnectFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/*"

  WebSocketDefaultLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref WebSocketDefaultFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/*"

  ApiGatewayDriverPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref HttpUpdateProfileFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${DrowsinessAlertApi}/*/*/*"

  # =====================================================================
  # IoT Rules
  # =====================================================================
  DrowsinessAlertRule:
    Type: AWS::IoT::TopicRule
    Properties:
      RuleName: !Sub drowsiness_alert_rule_${Environment}
      TopicRulePayload:
        RuleDisabled: false
        Sql: "SELECT * FROM 'vehicle/alerts/drowsiness'"
        Actions:
          - Lambda:
              FunctionArn: !GetAtt ProcessDrowsinessAlertFunction.Arn

  DriverProfileRule:
    Type: AWS::IoT::TopicRule
    Properties:
      RuleName: !Sub driver_profile_rule_${Environment}
      TopicRulePayload:
        RuleDisabled: false
        Sql: "SELECT * FROM 'vehicle/driver/profile'"
        Actions:
          - Lambda:
              FunctionArn: !GetAtt UpdateDriverProfileFunction.Arn

# =====================================================================
# Outputs
# =====================================================================
Outputs:
  DriversTableName:
    Description: Name of the DynamoDB table for driver profiles
    Value: !Ref DriversTable
    Export:
      Name: !Sub "${AWS::StackName}-DriversTable"

  AlertsTableName:
    Description: Name of the DynamoDB table for drowsiness alerts
    Value: !Ref AlertsTable
    Export:
      Name: !Sub "${AWS::StackName}-AlertsTable"

  WebSocketConnectionsTableName:
    Description: Name of the DynamoDB table for WebSocket connections
    Value: !Ref WebSocketConnectionsTable
    Export:
      Name: !Sub "${AWS::StackName}-WebSocketConnectionsTable"

  UpdateDriverProfileFunctionArn:
    Description: ARN of the Lambda function for updating driver profiles
    Value: !GetAtt UpdateDriverProfileFunction.Arn

  ProcessDrowsinessAlertFunctionArn:
    Description: ARN of the Lambda function for processing drowsiness alerts
    Value: !GetAtt ProcessDrowsinessAlertFunction.Arn

  LambdaExecutionRoleArn:
    Description: Lambda execution role ARN
    Value: !GetAtt LambdaExecutionRole.Arn

  DrowsinessAlertRuleArn:
    Description: IoT Rule ARN for drowsiness alerts
    Value: !GetAtt DrowsinessAlertRule.Arn

  DriverProfileRuleArn:
    Description: IoT Rule ARN for driver profile updates
    Value: !GetAtt DriverProfileRule.Arn

  IotPolicyName:
    Description: Name of the IoT policy
    Value: !Ref DrowsinessAlertPolicy

  IotEndpoint:
    Description: AWS IoT Core Data-ATS endpoint (for MQTT clients)
    Value: !Sub "${AWS::Region}.amazonaws.com"

  ApiEndpoint:
    Description: API Gateway endpoint URL for driver profile updates
    Value: !Sub "https://${DrowsinessAlertApi}.execute-api.${AWS::Region}.amazonaws.com/${Environment}/driver-profile"

  WebSocketApiEndpoint:
    Description: WebSocket API Gateway endpoint URL for real-time ambulance dashboard
    Value: !Sub "wss://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/${Environment}"

  WebSocketApiId:
    Description: WebSocket API Gateway ID
    Value: !Ref WebSocketApi

  WebSocketApiEndpointUrl:
    Description: WebSocket API Gateway endpoint URL (HTTP)
    Value: !Sub "https://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/${Environment}" 